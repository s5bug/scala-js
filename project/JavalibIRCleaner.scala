package build

import org.scalajs.ir._
import org.scalajs.ir.ClassKind
import org.scalajs.ir.Names._
import org.scalajs.ir.Trees._
import org.scalajs.ir.Types._

import java.io._
import java.net.URI
import java.nio.file.Files

import scala.collection.mutable

import sbt.{Logger, MessageOnlyException}

/** Postprocessor for the IR of the javalanglib, to remove all references to
 *  JS types in the Scala library, and ensure that there remains no other
 *  reference to the Scala library.
 *
 *  This ensures that the IR of the javalanglib is truly independent of Scala.
 *
 *  The main task is to *completely* erase all references to JS types to
 *  `j.l.Object`. This includes:
 *
 *  - Delete (or do not copy over) .sjsir files that define abstract and native
 *    JS types.
 *  - Erase references to JS types in method signatures and `TypeRef`s to
 *    `java.lang.Object`.
 *  - Eagerly dereference `LoadJSConstructor` and `LoadJSModule` by "inlining"
 *    the JS load spec of the mentioned class ref.
 *
 *  Afterwards, we check that the IR does not contain any reference to classes
 *  under the `scala.*` package.
 */
final class JavalibIRCleaner(baseDirectoryURI: URI) {
  private val JavaIOSerializable = ClassName("java.io.Serializable")
  private val ScalaSerializable = ClassName("scala.Serializable")

  private val writeReplaceMethodName =
    MethodName("writeReplace", Nil, ClassRef(ObjectClass))

  def cleanIR(dependencyFiles: Seq[File], libFileMappings: Seq[(File, File)],
      logger: Logger): Set[File] = {

    val errorManager = new ErrorManager(logger)

    val libIRMappings = for {
      (input, output) <- libFileMappings
    } yield {
      (readIR(input), output)
    }

    val jsTypes = {
      val dependencyIR = dependencyFiles.iterator.map(readIR(_))
      val libIR = libIRMappings.iterator.map(_._1)
      getJSTypes(dependencyIR ++ libIR)
    }

    val resultBuilder = Set.newBuilder[File]

    for ((tree, output) <- libIRMappings) {
      import ClassKind._

      tree.kind match {
        case Class | ModuleClass | Interface | HijackedClass =>
          val cleanedTree = cleanTree(tree, jsTypes, errorManager)
          writeIRFile(output, cleanedTree)
          resultBuilder += output

        case AbstractJSType | NativeJSClass | NativeJSModuleClass =>
          // discard

        case JSClass | JSModuleClass =>
          errorManager.reportError(
              s"found non-native JS class ${tree.className.nameString}")(tree.pos)
      }
    }

    if (errorManager.hasErrors) {
      throw new MessageOnlyException(
          s"There were ${errorManager.errorCount} errors while " +
          "postprocessing the IR of the javalanglib. " +
          "The javalanglib must be written in a style that does not leak any " +
          "reference to the Scala library.")
    }

    resultBuilder.result()
  }

  private final class ErrorManager(logger: Logger) {
    private val seenErrors = mutable.Set.empty[String]
    private var _errorCount: Int = 0

    def reportError(msg: String)(implicit pos: Position): Unit = {
      val fileStr = baseDirectoryURI.relativize(pos.source).toString
      val fullMessage = s"$msg at $fileStr:${pos.line}:${pos.column}"
      if (seenErrors.add(fullMessage)) {
        logger.error(fullMessage)
        _errorCount += 1
      }
    }

    def hasErrors: Boolean = _errorCount != 0

    def errorCount: Int = _errorCount
  }

  private def readIR(file: File): ClassDef = {
    import java.nio.ByteBuffer

    val bytes = Files.readAllBytes(file.toPath())
    val buffer = ByteBuffer.wrap(bytes)
    Serializers.deserialize(buffer)
  }

  private def writeIRFile(file: File, tree: ClassDef): Unit = {
    Files.createDirectories(file.toPath().getParent())
    val outputStream =
      new BufferedOutputStream(new FileOutputStream(file))
    try {
      Serializers.serialize(outputStream, tree)
    } finally {
      outputStream.close()
    }
  }

  private def getJSTypes(trees: Iterator[ClassDef]): Map[ClassName, ClassDef] =
    trees.filter(_.kind.isJSType).map(t => t.className -> t).toMap

  private def cleanTree(tree: ClassDef, jsTypes: Map[ClassName, ClassDef],
      errorManager: ErrorManager): ClassDef = {
    new ClassDefCleaner(tree.className, jsTypes, errorManager)
      .cleanClassDef(tree)
  }

  private final class ClassDefCleaner(enclosingClassName: ClassName,
      jsTypes: Map[ClassName, ClassDef], errorManager: ErrorManager)
      extends Transformers.ClassTransformer {

    def cleanClassDef(tree: ClassDef): ClassDef = {
      import tree._

      // Preprocess the super interface list
      val newInterfaces = transformInterfaceList(interfaces)

      /* Remove the `private def writeReplace__O` generated by scalac 2.13+
       * in the companion of serializable classes.
       */
      val newMemberDefs = memberDefs.filter {
        case MethodDef(_, MethodIdent(`writeReplaceMethodName`), _, _, _, _) =>
          false
        case _ =>
          true
      }

      val preprocessedTree = ClassDef(name, originalName, kind, jsClassCaptures,
          superClass, newInterfaces, jsSuperClass, jsNativeLoadSpec,
          newMemberDefs, topLevelExportDefs)(
          optimizerHints)(pos)

      validateClassName(preprocessedTree.name.name)
      for (superClass <- preprocessedTree.superClass)
        validateClassName(superClass.name)
      for (interface <- preprocessedTree.interfaces)
        validateClassName(interface.name)

      val transformedClassDef =
        Hashers.hashClassDef(this.transformClassDef(preprocessedTree))

      postTransformChecks(transformedClassDef)
      transformedClassDef
    }

    private def transformInterfaceList(
        interfaces: List[ClassIdent]): List[ClassIdent] = {

      /* Replace references to scala.Serializable by java.io.Serializable.
       * This works around the fact that scalac adds scala.Serializable to the
       * companion object of any class that extends java.io.Serializable.
       */

      if (!interfaces.exists(_.name == ScalaSerializable)) {
        interfaces
      } else if (interfaces.exists(_.name == JavaIOSerializable)) {
        interfaces.filter(_.name != ScalaSerializable)
      } else {
        interfaces.map { ident =>
          if (ident.name == ScalaSerializable)
            ClassIdent(JavaIOSerializable)(ident.pos)
          else
            ident
        }
      }
    }

    override def transformMemberDef(memberDef: MemberDef): MemberDef = {
      super.transformMemberDef(memberDef) match {
        case m @ MethodDef(flags, name, originalName, args, resultType, body) =>
          MethodDef(flags, transformMethodIdent(name), originalName, args,
              resultType, body)(m.optimizerHints, m.hash)(m.pos)
        case m =>
          m
      }
    }

    override def transform(tree: Tree, isStat: Boolean): Tree = {
      implicit val pos = tree.pos

      val result = super.transform(tree, isStat) match {
        case New(className, ctor, args) =>
          New(className, transformMethodIdent(ctor), args)

        case t: Apply =>
          Apply(t.flags, t.receiver, transformMethodIdent(t.method),
              t.args)(t.tpe)
        case t: ApplyStatically =>
          validateNonJSClassName(t.className)
          ApplyStatically(t.flags, t.receiver, t.className,
              transformMethodIdent(t.method), t.args)(t.tpe)
        case t: ApplyStatic =>
          validateNonJSClassName(t.className)
          ApplyStatic(t.flags, t.className,
              transformMethodIdent(t.method), t.args)(t.tpe)

        case NewArray(typeRef, lengths) =>
          NewArray(transformArrayTypeRef(typeRef), lengths)
        case ArrayValue(typeRef, elems) =>
          ArrayValue(transformArrayTypeRef(typeRef), elems)

        case t: IsInstanceOf =>
          validateType(t.testType)
          t

        case LoadJSConstructor(className) =>
          genLoadFromLoadSpecOf(className)
        case LoadJSModule(className) =>
          genLoadFromLoadSpecOf(className)

        case t: ClassOf =>
          if (transformTypeRef(t.typeRef) != t.typeRef)
            reportError(s"illegal ClassOf(${t.typeRef})")
          t

        case t =>
          t
      }

      validateType(result.tpe)
      result
    }

    private def genLoadFromLoadSpecOf(className: ClassName)(
        implicit pos: Position): Tree = {
      jsTypes.get(className) match {
        case Some(classDef) =>
          classDef.jsNativeLoadSpec match {
            case Some(loadSpec) =>
              genLoadFromLoadSpec(loadSpec)
            case None =>
              reportError(
                  s"${className.nameString} does not have a load spec " +
                  "(this shouldn't have happened at all; bug in the compiler?)")
              JSGlobalRef("Object")
          }
        case None =>
          reportError(s"${className.nameString} is not a JS type")
          JSGlobalRef("Object")
      }
    }

    private def genLoadFromLoadSpec(loadSpec: JSNativeLoadSpec)(
        implicit pos: Position): Tree = {
      loadSpec match {
        case JSNativeLoadSpec.Global(globalRef, path) =>
          path.foldLeft[Tree](JSGlobalRef(globalRef)) { case (ref, segment) => JSSelect(ref, StringLiteral(segment)) }
        case _ =>
          reportError(
              s"unsupported load spec $loadSpec; " +
              "only @JSGlobal without `.` is supported")
          JSGlobalRef("Object")
      }
    }

    private def transformMethodIdent(ident: MethodIdent): MethodIdent = {
      implicit val pos = ident.pos
      val methodName = ident.name
      val paramTypeRefs = methodName.paramTypeRefs
      val newParamTypeRefs = paramTypeRefs.map(transformTypeRef)
      val resultTypeRef = methodName.resultTypeRef
      val newResultTypeRef = transformTypeRef(resultTypeRef)
      if (newParamTypeRefs == paramTypeRefs && newResultTypeRef == resultTypeRef) {
        ident
      } else {
        val newMethodName = MethodName(methodName.simpleName,
            newParamTypeRefs, newResultTypeRef, methodName.isReflectiveProxy)
        MethodIdent(newMethodName)
      }
    }

    private def transformClassRef(cls: ClassRef)(
        implicit pos: Position): ClassRef = {
      if (jsTypes.contains(cls.className)) {
        ClassRef(ObjectClass)
      } else {
        validateClassName(cls.className)
        cls
      }
    }

    private def transformArrayTypeRef(typeRef: ArrayTypeRef)(
        implicit pos: Position): ArrayTypeRef = {
      typeRef.base match {
        case _: PrimRef =>
          typeRef
        case ClassRef(baseClassName) =>
          if (jsTypes.contains(baseClassName)) {
            ArrayTypeRef(ClassRef(ObjectClass), typeRef.dimensions)
          } else {
            validateClassName(baseClassName)
            typeRef
          }
      }
    }

    private def transformTypeRef(typeRef: TypeRef)(
        implicit pos: Position): TypeRef = typeRef match {
      case typeRef: PrimRef      => typeRef
      case typeRef: ClassRef     => transformClassRef(typeRef)
      case typeRef: ArrayTypeRef => transformArrayTypeRef(typeRef)
    }

    private def postTransformChecks(classDef: ClassDef): Unit = {
      // Check that no two methods have been erased to the same name
      val seenMethodNames = mutable.Set.empty[(MemberNamespace, MethodName)]
      for (m <- classDef.memberDefs) {
        m match {
          case MethodDef(flags, name, _, _, _, _) =>
            if (!seenMethodNames.add((flags.namespace, name.name))) {
              reportError(
                  s"duplicate method name ${name.name.nameString} after erasure")(
                  m.pos)
            }
          case _ =>
        }
      }
    }

    private def validateType(tpe: Type)(implicit pos: Position): Unit = {
      tpe match {
        case ClassType(cls) =>
          validateClassName(cls)
        case ArrayType(ArrayTypeRef(ClassRef(cls), _)) =>
          validateClassName(cls)
        case _ =>
          // ok
      }
    }

    private def validateClassName(cls: ClassName)(implicit pos: Position): Unit = {
      if (cls.nameString.startsWith("scala."))
        reportError(s"Illegal reference to Scala class ${cls.nameString}")
    }

    private def validateNonJSClassName(cls: ClassName)(implicit pos: Position): Unit = {
      if (jsTypes.contains(cls))
        reportError(s"Invalid reference to JS class ${cls.nameString}")
      else
        validateClassName(cls)
    }

    private def reportError(msg: String)(implicit pos: Position): Unit = {
      errorManager.reportError(s"$msg in ${enclosingClassName.nameString}")
    }
  }
}
